<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="读书笔记,GCD," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="本文主要对GCD的概念、API以及实现进行梳理.  GCD的概念.GCD,全称是Grand Central Dispatch,它是C语言的API.GCD的核心 : 将block(任务)添加到queue(队列)中. 根据官方文档ConcurrencyProgramingGuide中的描述:  One of the technologies for starting tasks asynchrono">
<meta name="keywords" content="读书笔记,GCD">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS读书笔记之Objective-C高级编程(GCD)">
<meta property="og:url" content="http://cherishJoy.com/2017/07/02/iOS读书笔记之Objective-C高级编程(GCD)/index.html">
<meta property="og:site_name" content="CherishJoy">
<meta property="og:description" content="本文主要对GCD的概念、API以及实现进行梳理.  GCD的概念.GCD,全称是Grand Central Dispatch,它是C语言的API.GCD的核心 : 将block(任务)添加到queue(队列)中. 根据官方文档ConcurrencyProgramingGuide中的描述:  One of the technologies for starting tasks asynchrono">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3284707-6bc3e528d1f6af77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3284707-f45caa56257e4edc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3284707-fb678966aa43d656.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3284707-0056ed1e30144d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3284707-f3653596b94fc20c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3284707-6c3c25dd9e0997a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3284707-586f1a2a16ddbc3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3284707-a95e193a3e60e949.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3284707-185cbde8895abd82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500">
<meta property="og:updated_time" content="2017-09-30T16:24:35.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS读书笔记之Objective-C高级编程(GCD)">
<meta name="twitter:description" content="本文主要对GCD的概念、API以及实现进行梳理.  GCD的概念.GCD,全称是Grand Central Dispatch,它是C语言的API.GCD的核心 : 将block(任务)添加到queue(队列)中. 根据官方文档ConcurrencyProgramingGuide中的描述:  One of the technologies for starting tasks asynchrono">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/3284707-6bc3e528d1f6af77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://cherishJoy.com/2017/07/02/iOS读书笔记之Objective-C高级编程(GCD)/"/>





  <title>iOS读书笔记之Objective-C高级编程(GCD) | CherishJoy</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CherishJoy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">路漫漫其修远兮,吾将上下而求索.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://cherishJoy.com/2017/07/02/iOS读书笔记之Objective-C高级编程(GCD)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherishJoy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CherishJoy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS读书笔记之Objective-C高级编程(GCD)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-02T00:54:03+08:00">
                2017-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categorys/iOS读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">iOS读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/07/02/iOS读书笔记之Objective-C高级编程(GCD)/" class="leancloud_visitors" data-flag-title="iOS读书笔记之Objective-C高级编程(GCD)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数</span>
                
                <span title="字数">
                  5,285 
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本文主要对GCD的概念、API以及实现进行梳理.</p>
</blockquote>
<h3 id="GCD的概念"><a href="#GCD的概念" class="headerlink" title="GCD的概念."></a>GCD的概念.</h3><h4 id="GCD-全称是Grand-Central-Dispatch-它是C语言的API"><a href="#GCD-全称是Grand-Central-Dispatch-它是C语言的API" class="headerlink" title="GCD,全称是Grand Central Dispatch,它是C语言的API."></a>GCD,全称是Grand Central Dispatch,它是C语言的API.</h4><p>GCD的核心 : 将block(任务)添加到queue(队列)中.</p>
<p>根据官方文档<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ConcurrencyandApplicationDesign/ConcurrencyandApplicationDesign.html#//apple_ref/doc/uid/TP40008091-CH100-SW8" target="_blank" rel="external">ConcurrencyProgramingGuide</a>中的描述:</p>
<blockquote>
<p>One of the technologies for starting tasks asynchronously is Grand Central Dispatch (GCD). This technology takes the thread management code you would normally write in your own applications and moves that code down to the system level. All you have to do is define the tasks you want to execute and add them to an appropriate dispatch queue. GCD takes care of creating the needed threads and of scheduling your tasks to run on those threads. Because the thread management is now part of the system, GCD provides a holistic approach to task management and execution, providing better efficiency than traditional threads.</p>
</blockquote>
<p>翻译如下:</p>
<blockquote>
<p>Grand Central Dispatch(GCD)是异步执行任务的技术之一.一般将应用程序中记述的线程管理用的代码在系统级中实现.开发者只需定义想执行的任务并追加到适当的Dispatch Queue中,GCD就能生成必要的线程并执行任务,这样就比以前的线程更有效率.</p>
</blockquote>
<h4 id="GCD使用步骤"><a href="#GCD使用步骤" class="headerlink" title="GCD使用步骤"></a>GCD使用步骤</h4><ul>
<li>创建任务 : 确定具体要做的事.<br>  GCD中的任务是使用block封装的.</li>
<li>将任务添加到队列中<br>  GCD会自动将队列中的任务取出,放到对应的线程中执行.<br>  任务的取出遵循队列的FIFO原则 : 先进先出,后进后出.</li>
</ul>
<h4 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 长时间处理</div><div class="line"> *</div><div class="line"> * 例如 AR 用画像识别</div><div class="line"> * 例如数据库访问</div><div class="line"> */</div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 长时间处理结束,主线程使用该处理结果</div><div class="line">     */</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 只有在主线程可以执行的处理</div><div class="line">         *</div><div class="line">         * 例如用户界面更新</div><div class="line">         */</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在GCD之前,Cocoa框架提供了NSObject类的<code>performSelectorInBackground:withObject:</code>实例方法和<code>performSelectorOnMainThread:withObject:waitUntilDone:</code>实例方法等简单的多线程编程技术.<br>以下方法等价于GCD的实现:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * NSObject performSelectorInBackground: withObject:方法中</div><div class="line"> * 执行后台线程</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)launchThreadByNSObject_performSelectorInBackground_withObject</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(doWork) withObject:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)doWork</div><div class="line">&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 因为书本是基于MRC环境所写,所以包含自动释放池,若在ARC环境下,以下语句会报错.</div><div class="line">     */</div><div class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 长时间处理</div><div class="line">     *</div><div class="line">     * 例如 AR 用画像识别</div><div class="line">     * 例如数据库访问</div><div class="line">     */</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 长时间处理结束,主线程使用该处理结果</div><div class="line">     */</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(doneWork) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</div><div class="line">    </div><div class="line">    [pool drain];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)doneWork</div><div class="line">&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 只有在主线程可以执行的处理</div><div class="line">     *</div><div class="line">     * 例如用户界面更新</div><div class="line">     */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="多线程执行原理总结"><a href="#多线程执行原理总结" class="headerlink" title="多线程执行原理总结"></a>多线程执行原理总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">单核CPU同一时间,CPU只能处理1个线程,只有1个线程在执行任务.</div><div class="line">多线程的同时执行 : 其实是CPU在多条线程之间快速切换(调度任务).</div><div class="line">如果CPU调度线程的速度足够快,就造成了多线程同时执行的假象.</div><div class="line">在多核CPU的情况下,就真正并行执行多个线程.</div></pre></td></tr></table></figure>
<p>因为<code>长时间的处理(耗时操作)</code>,会妨碍主线程的运行循环的执行,所以需要进行多线程编程,如:<code>异步</code>创建<code>子线程</code>去处理<code>耗时操作</code>,耗时操作结束后,再<code>回到主线程刷新UI</code>.这种方式不会妨碍主线程的运行循环的执行,并能提高程序响应性能.<br>如图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3284707-6bc3e528d1f6af77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="主线程运行循环图"></p>
<h3 id="CCD的API"><a href="#CCD的API" class="headerlink" title="CCD的API."></a>CCD的API.</h3><h4 id="Dispatch-Queue"><a href="#Dispatch-Queue" class="headerlink" title="Dispatch Queue"></a><strong>Dispatch Queue</strong></h4><p>开发者要做的只是定义想执行的任务并追加到适当的Dispatch Queue中.<br>源代码表示:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 想执行的任务</div><div class="line">     */</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Dispatch Queue是执行处理的等待队列.Dispatch Queue按照追加的顺序(先进先出FIFO,First-In-First-Out)执行处理.<br>如图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3284707-f45caa56257e4edc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="通过Dispatch Queue执行处理"></p>
<p>Dispatch Queue分为4种队列,分别是<code>Serial Queue</code>(串行队列)、<code>Concurrent Queue</code>(并发队列)、<code>Main Dispatch Queue</code>(主调度队列)、<code>Global Dispatch Queue</code>(全局并发队列).</p>
<p>根据官方文档<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW1" target="_blank" rel="external">Dispatch Queues</a>中的描述:</p>
<p>1.Serial Queue</p>
<blockquote>
<p>Serial queues (also known as private dispatch queues) execute one task at a time in the order in which they are added to the queue.<br>If you create four serial queues, each queue executes only one task at a time but up to four tasks could still execute concurrently, one from each queue. </p>
</blockquote>
<p>翻译如下:</p>
<blockquote>
<p>串行队列（也称为私有调度队列）按顺序将其中一个任务添加到队列中,并且一次只执行一个任务.<br>如果创建四个串行队列,每个队列一次只执行一个任务,但最多四个任务可以并发执行,每个队列中有一个任务.</p>
</blockquote>
<p>如图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3284707-fb678966aa43d656.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="只使用一线程"></p>
<p>代码:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"mySerialDispatchQueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"一个丁老头,欠我两个蛋"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"他说三天还,四天还没还"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"仔细想一想,就是大傻蛋"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"买了三根葱,花了3毛3"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"买个大西瓜,用了6毛6"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"买串糖葫芦,没了7毛7"</span>);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>根据串行队列特点,从上到下执行每个block中的任务,即<code>丁老头</code>,再<code>还钱</code>,再到<code>大傻蛋</code>,同时执行的处理只有1个.<br>结果如下:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3284707-0056ed1e30144d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="丁老头"></p>
<p>2.Concurrent Queue</p>
<blockquote>
<p>Concurrent queues (also known as a type of global dispatch queue) execute one or more tasks concurrently, but tasks are still started in the order in which they were added to the queue. The currently executing tasks run on distinct threads that are managed by the dispatch queue. </p>
</blockquote>
<p>翻译如下:</p>
<blockquote>
<p>并发队列（也称为全局调度队列）同时执行一个或多个任务，但任务仍然按照它们添加到队列的顺序执行.当前执行的任务运行在不同线程上,而这些线程由调度队列所管理.</p>
</blockquote>
<p>如图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3284707-f3653596b94fc20c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="使用多个线程"></p>
<p>将<code>DISPATCH_QUEUE_SERIAL</code>更改为<code>DISPATCH_QUEUE_CONCURRENT</code>.</p>
<p>代码:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"myConcurrentDispatchQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure></p>
<p>那么丁老头的执行顺序就是不确定的,即并行执行.<br>注意:<code>在不能改变执行的处理顺序或不想并行执行多个处理时使用Serial Dispatch Queue.</code></p>
<p>3.Main Dispatch Queue</p>
<blockquote>
<p>The main dispatch queue is a globally available serial queue that executes tasks on the application’s main thread. This queue works with the application’s run loop (if one is present) to interleave the execution of queued tasks with the execution of other event sources attached to the run loop. </p>
</blockquote>
<p>翻译如下:</p>
<blockquote>
<p>主调度队列是一个全局可用的串行队列,它在应用程序的主线程上执行任务.该队列与应用程序的运行循环（如果有的话）一起工作,即该队列的任务与运行循环的其他事件源交叉执行.</p>
</blockquote>
<p>如图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3284707-6c3c25dd9e0997a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="主队列执行情况"></p>
<p>4.Global Dispatch Queue</p>
<blockquote>
<p>The system provides each application with four concurrent dispatch queues. These queues are global to the application and are differentiated only by their priority level. Because they are global, you do not create them explicitly. Instead, you ask for one of the queues using the <a href="https://developer.apple.com/documentation/dispatch/1452927-dispatch_get_global_queue" target="_blank" rel="external">dispatch_get_global_queue</a><br> function</p>
</blockquote>
<p>翻译如下:</p>
<blockquote>
<p>系统为每个应用程序提供四个并发调度队列.这些队列对应用程序而言是全局的,而且只对它们的优先级进行区分.因为它们是全局的，所以不需要明确地创建它们.相反,你可以用dispatch_get_global_queue函数的获取其中一个队列.</p>
</blockquote>
<p>优先级如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">Dispatch Queue的种类</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Main Dispatch Queue</td>
<td style="text-align:center">Serial Diapatch Queue</td>
<td style="text-align:center">主线程执行</td>
</tr>
<tr>
<td style="text-align:center">Global Dispatch Queue(High Priority)</td>
<td style="text-align:center">Concurrent Dispatch Queue</td>
<td style="text-align:center">执行优先级:高(最高优先级)</td>
</tr>
<tr>
<td style="text-align:center">Global Dispatch Queue(Default Priority)</td>
<td style="text-align:center">Concurrent Dispatch Queue</td>
<td style="text-align:center">执行优先级:默认</td>
</tr>
<tr>
<td style="text-align:center">Global Dispatch Queue(Low Priority)</td>
<td style="text-align:center">Concurrent Dispatch Queue</td>
<td style="text-align:center">执行优先级:低</td>
</tr>
<tr>
<td style="text-align:center">Global Dispatch Queue(Background Priority)</td>
<td style="text-align:center">Concurrent Dispatch Queue</td>
<td style="text-align:center">执行优先级:后台</td>
</tr>
</tbody>
</table>
<p>代码:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 主队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> mainDiapatchQueue = dispatch_get_main_queue();</div><div class="line"><span class="comment">// 高优先级全局并发队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> globalDiapatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</div><div class="line"><span class="comment">// 默认先级全局并发队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> globalDiapatchQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="comment">// 低优先级全局并发队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> globalDiapatchQueueLow = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</div><div class="line"><span class="comment">// 后台先级全局并发队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> globalDiapatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>总结:</p>
<ul>
<li><p>串行队列<br>串行队列里面的任务,都是<code>按顺序依次调度执行</code>,前面一个任务<code>未执行完</code>,后面的任务不会被调度执行.</p>
</li>
<li><p>并发队列 == 全局并发队列<br>可以同时调度多个任务同时的执行.</p>
</li>
<li><p>主队列<br>主队列由系统创建好的,可直接获取.<br>主队列中的任务,一定是在主线程中执行.主要进行线程间的通信.<br>只有在主线程空闲的时候,主队列才会调度其中的任务执行.</p>
</li>
<li><p>全局队列<br>全局队列又叫全局并发队列.<br>由系统创建,可直接获取,调度任务的效果等同于并发队列.</p>
</li>
</ul>
<h4 id="dispatch-queue-create"><a href="#dispatch-queue-create" class="headerlink" title="dispatch_queue_create"></a><strong>dispatch_queue_create</strong></h4><p>该ApI主要是为了生成dispatch queue.<br>代码:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 第1个参数:指定队列的名称</div><div class="line"> * 第2个参数:指定队列的类型</div><div class="line"> */</div><div class="line"><span class="comment">// 生成串行队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> mySerialDiapatchQueue = dispatch_queue_create(<span class="string">"MySerialDiapatchQueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="comment">// 生成并发队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> myConcurrentDiapatchQueue = dispatch_queue_create(<span class="string">"MyConcurrentDiapatchQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure></p>
<p>因为一个串行队列,只生成并使用一个线程,所以创建几个串行队列就生成几个线程,线程过多,会消耗大量内存,影响系统响应性能.</p>
<p>问题:<br>多个线程竞争同一资源时,会出现数据安全问题.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3284707-586f1a2a16ddbc3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="数据安全问题"></p>
<p>例子:<br>线程A、线程B、线程C都准备使用数据data,data的值为36,<code>线程A先将data值从36改为20</code>,此时线程B要使用data,他要读取data值,在正常情况下,<code>线程B读取到的值应该为36</code>,但是data的值在线程A中被改成20,导致线程B获取到data值不正确.C的事就不说了,我B都错了,难道你C还想要对的数据?</p>
<p>解决:<br>使用Serial Diapatch Queue可以保证数据的安全.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3284707-a95e193a3e60e949.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="解决"></p>
<p>例子:<br>还是A、B、C三兄弟,A在用data,B也想用data,但是B只能乖乖等着,A用完data,data值是否改变不重要,因为,B这时候用的是A的结果.不会产生安全问题.<code>好像C就是打酱油的,没排上用场,好吧,此处省略C一万字...</code></p>
<p>书中提及:<code>虽然存在ARC自动管理内存,但是生成的Dispatch Queue必须由程序员负责释放</code>.所以我测试了,在ARC环境下,用书中方法对队列进行release操作,但是提示<code>ARC forbids explicit message send of &#39;release&#39;</code>错误,所以ARC已经对队列进行了引用计数的增减,不需要我们手动release了.</p>
<h4 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a><strong>dispatch_set_target_queue</strong></h4><p>该API主要用于变更生成的队列的执行优先级的.<br>通过<code>dispatch_queue_create</code>生成的队列,不论串行队列还是并发队列,它们与<code>默认优先级的全局并发队列</code>的优先级相同.所以,可以通过<code>dispatch_set_target_queue</code>,将串行队列的优先级改为在后台执行.<br>代码:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 串行队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> mySerialDiapatchQueue = dispatch_queue_create(<span class="string">"MySerialDiapatchQueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="comment">// 后台先级全局并发队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> globalDiapatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 第1个参数:准备变更优先级的队列</div><div class="line"> * 第2个参数:变更后的相同优先级的的队列</div><div class="line"> */</div><div class="line"><span class="comment">// 变更优先级</span></div><div class="line">dispatch_set_target_queue(mySerialDiapatchQueue, globalDiapatchQueueBackground);</div></pre></td></tr></table></figure></p>
<p>书中提及此方法的作用:多个串行队列,假设有3个串行队列A、B、C,A、B、C串行队列原本是并行执行的,每个队列执行自己的一个任务.但是通过<code>dispatch_set_target_queue</code>方法,将A的优先级设置成B的优先级,此时,只能执行A中的任务.因此这种方法,可以防止处理并行执行.</p>
<h4 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a><strong>dispatch_after</strong></h4><p>dispatch_after这个是大家常用的API,主要进行延迟操作.但是延迟只说明再一定时间后,将任务添加到队列中执行,真正开始执行任务,可能因为主线程本身的处理有延迟,导致时间不准确.<br>代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * dispatch_time:获取dispatch_time_t类型的时间</div><div class="line"> * DISPATCH_TIME_NOW:当前时间</div><div class="line"> * NSEC_PER_SEC:单位秒</div><div class="line"> */</div><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span>ull * <span class="built_in">NSEC_PER_SEC</span>));</div><div class="line"></div><div class="line">    <span class="comment">//  dispatch_after:在3秒后,将任务添加到队列中</span></div><div class="line">    dispatch_after(time, dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"wait at least three second"</span>);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>附上第2个参数的时间说明<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSEC</span>：纳秒</div><div class="line">USEC：微妙</div><div class="line">SEC：秒</div><div class="line">PER：每</div><div class="line"><span class="meta">#define NSEC_PER_SEC 1000000000ull 每秒有多少纳秒</span></div><div class="line"><span class="meta">#define NSEC_PER_MSEC 1000000ull 每毫秒有多少纳秒</span></div><div class="line"><span class="meta">#define USEC_PER_SEC 1000000ull 每秒有多少微秒</span></div><div class="line"><span class="meta">#define NSEC_PER_USEC 1000ull 每微妙有多少纳秒</span></div></pre></td></tr></table></figure></p>
<h4 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch group"></a><strong>dispatch group</strong></h4><p>dispatch group即调度组.<br>作用:调度组中的所有异步任务执行结束之后,会得到统一的通知.</p>
<p>使用场景<br>监听一组异步任务是否执行结束,如果执行结束就能够得到统一的通知.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建默认优先级的全局并发队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建调度组</span></div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片A"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片B"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片C"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"处理下载完成的图片"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>打印结果:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-01</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">15.620007</span>+<span class="number">0800</span> BYGCDDemo[<span class="number">368</span>:<span class="number">102016</span>] 下载图片B</div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-01</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">15.620175</span>+<span class="number">0800</span> BYGCDDemo[<span class="number">368</span>:<span class="number">102016</span>] 下载图片C</div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-01</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">15.620219</span>+<span class="number">0800</span> BYGCDDemo[<span class="number">368</span>:<span class="number">102016</span>] 下载图片A</div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-01</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">15.635798</span>+<span class="number">0800</span> BYGCDDemo[<span class="number">368</span>:<span class="number">101977</span>] 处理下载完成的图片</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-01</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">15.620007</span>+<span class="number">0800</span> BYGCDDemo[<span class="number">368</span>:<span class="number">102016</span>] 下载图片C</div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-01</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">15.620175</span>+<span class="number">0800</span> BYGCDDemo[<span class="number">368</span>:<span class="number">102016</span>] 下载图片B</div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-01</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">15.620219</span>+<span class="number">0800</span> BYGCDDemo[<span class="number">368</span>:<span class="number">102016</span>] 下载图片A</div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-01</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">15.635798</span>+<span class="number">0800</span> BYGCDDemo[<span class="number">368</span>:<span class="number">101977</span>] 处理下载完成的图片</div></pre></td></tr></table></figure></p>
<p>总之,下载图片A、B、C是并行执行顺序不一,但是,处理下载完成的图片的操作一定是在最后执行,且只在A、B、C操作结束后,调度组收到结束通知,才去执行<code>处理下载完成的图片</code>.</p>
<p>可以使用<code>dispatch_group_wait</code>方法实现以上相同功能<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片A"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片B"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片C"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 第1个参数:执行任务的调度组</div><div class="line"> * 第2个参数:等待时间</div><div class="line"> */</div><div class="line"><span class="keyword">long</span> result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"处理下载完成的图片"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"以上调度组中存在未完成的任务"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当调度组中的方法未执行完成,<code>dispatch_group_wait</code>方法中的<code>DISPATCH_TIME_FOREVER</code>属于永久等待状态,且<code>dispatch_group_wait</code>只调用不返回,即result的值恒不等0,执行<code>dispatch_group_wait</code>方法所在的线程停止,直到调度组中的任务完成,执行<code>dispatch_group_wait</code>方法所在的线程开始工作,result为0,所以可以根据result值判断,图片是否下载完成.</p>
<p>若将以上代码中的<code>DISPATCH_TIME_FOREVER</code>更改为<code>DISPATCH_TIME_NOW</code>,那么当程序执行到<code>dispatch_group_wait</code>方法,直接进行判断,而不用等待.此时,A、B、C的下载工作可能都还没执行完,就出现下列结果:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-01</span> <span class="number">14</span>:<span class="number">52</span>:<span class="number">14.498329</span>+<span class="number">0800</span> BYGCDDemo[<span class="number">421</span>:<span class="number">115796</span>] 以上调度组中存在未完成的任务</div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-01</span> <span class="number">14</span>:<span class="number">52</span>:<span class="number">14.498421</span>+<span class="number">0800</span> BYGCDDemo[<span class="number">421</span>:<span class="number">115825</span>] 下载图片B</div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-01</span> <span class="number">14</span>:<span class="number">52</span>:<span class="number">14.498473</span>+<span class="number">0800</span> BYGCDDemo[<span class="number">421</span>:<span class="number">115825</span>] 下载图片C</div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-01</span> <span class="number">14</span>:<span class="number">52</span>:<span class="number">14.498350</span>+<span class="number">0800</span> BYGCDDemo[<span class="number">421</span>:<span class="number">115828</span>] 下载图片A</div></pre></td></tr></table></figure></p>
<p>不过推荐使用<code>dispatch_group_notify</code>方法,主要是简化代码.</p>
<h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a><strong>dispatch_barrier_async</strong></h4><p><code>dispatch_barrier_async</code>在并发执行任务的队列中追加处理任务,该任务在等待前面并发任务执行完成之后才执行,当<code>dispatch_barrier_async</code>中的任务执行完成,才会继续执行后续的并发执行的任务.</p>
<p>如图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3284707-185cbde8895abd82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="dispatch_barrier_async追加的处理"></p>
<p>代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"MyConcurrentDiapatchQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第1次读取data值"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第2次读取data值"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第1次写入data值"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第3次读取data值"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第4次读取data值"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>分析:<br>假设,data初始值为<code>36</code>,因为这些任务是并发执行的,可能先执行了<code>第1次写入data值</code>,写入之后的值为<code>20</code>之后再进行<code>第1次读取data值</code>,导致读取到值<code>20</code>与期望值<code>36</code>不符合,所以为了避免这种情况发生,将<code>第1次写入data值</code>的方法改为:<code>dispatch_barrier_async</code>,这样,程序先并发执行<code>第1次读取data值</code>和<code>第2次读取data值</code>,等待这两个任务执行完成,才开始<code>dispatch_barrier_async</code>中的任务,当<code>dispatch_barrier_async</code>中的任务完成后,继续并发执行<code>第3次读取data值</code>和<code>第4次读取data值</code>.这样既保证了<code>前两次读取数据</code>的正确以及<code>第1次写入操作</code>的成功,也保证<code>后续读取操作</code>能正确读取<code>被改写过的值</code>.</p>
<p>总结:<code>dispatch_barrier_async 方法可实现高效率数据库的数据访问和文件访问.</code></p>
<h4 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch_sync"></a><strong>dispatch_sync</strong></h4><p><code>dispatch_sync</code>方法意味着<code>同步</code>,即将指定的任务<code>同步</code>地添加到指定的队列中,在追加其他任务之前,会一直等待.<br>在主线程中调用<code>dispatch_sync</code>方法会引起死锁问题.<br>代码:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</div><div class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"我非要在主队列中执行同步任务"</span>);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"我非要在主队列中执行同步任务"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>分析:<br>在上文<code>主队列</code>的概念中提到,只有在主线程空闲的时候,才会执行主队列中的任务.仔细查看以上两种方法,当主队列想要执行队列中的block,就必须等待主线程空闲,但是,此时主队列的代码正在主线程中运行,所以主线程是不空闲,既然不空闲,那么主队列的block就无法执行.<br>一句话就是:主队列的block等待主线程空闲,但主队列自己却占着主线程的位置.</p>
<p>建议使用:<code>dispatch_async</code> + <code>主队列</code>.</p>
<h4 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a><strong>dispatch_apply</strong></h4><p>dispatch_apply也会等待全部处理执行结束.<br>代码:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 第1个参数:重复的次数</div><div class="line"> * 第2个参数:执行任务的队列</div><div class="line"> * 第3个参数:追加的处理</div><div class="line"> */</div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%zu"</span>,index);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"done"</span>);</div></pre></td></tr></table></figure></p>
<p>结果:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">6</span></div><div class="line"><span class="number">8</span></div><div class="line"><span class="number">9</span></div><div class="line"><span class="number">7</span></div><div class="line">done</div></pre></td></tr></table></figure></p>
<p>第3个参数是<code>带有参数的block</code>,为了区分追加到队列中block.<br>如果对数组中的每个对象进行处理.推荐使用以下方法:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *arr = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"10"</span>,<span class="string">@"20"</span>,<span class="string">@"30"</span>, <span class="literal">nil</span>];</div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">   </div><div class="line">    <span class="comment">// 等待 dispatch_apply 方法中全部处理执行结束</span></div><div class="line">    dispatch_apply(arr.count, queue, ^(size_t index) &#123;</div><div class="line">        <span class="comment">// 并列处理包含在数组中全部对象</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zu:%@"</span>,index,[arr objectAtIndex:index]);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">       </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"用户界面更新"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="dispatch-suspend"><a href="#dispatch-suspend" class="headerlink" title="dispatch_suspend"></a><strong>dispatch_suspend</strong></h4><p>dispatch_suspend挂起队列,表示队列中还未执行的任务会暂停,已经执行的任务会继续执行.<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_suspend(queue);</div></pre></td></tr></table></figure></p>
<h4 id="dispatch-resume"><a href="#dispatch-resume" class="headerlink" title="dispatch_resume"></a><strong>dispatch_resume</strong></h4><p>dispatch_suspend恢复队列,表示队列中还未执行的任务会恢复执行.<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_resume(queue);</div></pre></td></tr></table></figure></p>
<h4 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch semaphore"></a><strong>dispatch semaphore</strong></h4><p><code>dispatch semaphore</code>是持有计数的信号.计数为0等待,计数为1或大于1,减去1而不等待.<br><code>dispatch semaphore</code>创建方式:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1表示计数的初始值</span></div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>遇到以下情况:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="built_in">NSMutableArray</span> *arr = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        </div><div class="line">        [arr addObject:[<span class="built_in">NSNumber</span> numberWithInt:i]];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>开启太多子线程,势必导致程序响应问题,以及内存错误,导致崩溃.<br>解决:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 生成dispatch semaphore</div><div class="line"> *</div><div class="line"> * dispatch semaphore的计数初始值为1</div><div class="line"> *</div><div class="line"> * 保证可同时访问NSMutableArray类对象的线程</div><div class="line"> * 同时只能有一个</div><div class="line"> */</div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</div><div class="line"><span class="built_in">NSMutableArray</span> *arr = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 等待dispatch semaphore</div><div class="line">         *</div><div class="line">         * 一直等待,直到计数值大于等于1</div><div class="line">         */</div><div class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 由于dispatch semaphore的计数值大于等于1</div><div class="line">         * 所以将dispatch semaphore的计数值减去1</div><div class="line">         * dispatch_semaphore_wait方法执行返回</div><div class="line">         *</div><div class="line">         * 执行到此时的dispatch semaphore的计数恒为0</div><div class="line">         * 由于可访问NSMutableArray类对象的线程只有1个</div><div class="line">         * 因此可安全地进行更新</div><div class="line">         */</div><div class="line">        [arr addObject:[<span class="built_in">NSNumber</span> numberWithInt:i]];</div><div class="line">        </div><div class="line">         <span class="comment">// dispatch_semaphore_signal 方法将dispatch semaphore的计数加1.</span></div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分析:<br>通过计数值去判断当前线程能否处理数组对象,计数初始值是1,跳过<code>dispatch_semaphore_wait</code>方法,处理对象之后,再减去1,值为0,此时若继续添加线程,肯定无法跳过<code>dispatch_semaphore_wait</code>方法,只能等待上一个线程通过<code>dispatch_semaphore_signal</code>方法把计数值改成1,即上一个线程已经完成对数组的处理,才能开始下一个线程的处理任务.</p>
<h4 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a><strong>dispatch_once</strong></h4><p>这是常用来创建单例的方法.<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> ViewController *instance;</div><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">    instance = [[ViewController alloc] init];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>分析:<br>在执行到<code>dispatch_once(&amp;onceToken, ^{</code>时打断点,可以看到onceToken结果是0,但是在末行<code>});</code>打断点,结果是1027,这个值是不确定,所以,每次执行<code>dispatch_once</code>时,都会判断<code>onceToken</code>的值,如果是0,执行block中的代码,非0,则不执行,达到创建单例的效果.</p>
<h3 id="CCD的实现"><a href="#CCD的实现" class="headerlink" title="CCD的实现."></a>CCD的实现.</h3><p>用于实现Dispatch Queue而使用的软件组件.</p>
<table>
<thead>
<tr>
<th style="text-align:center">组件名称</th>
<th style="text-align:center">提供技术</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">libdispatch</td>
<td style="text-align:center">Diapatch Queue</td>
</tr>
<tr>
<td style="text-align:center">Libc ( pthreads )</td>
<td style="text-align:center">pthread_workqueue</td>
</tr>
<tr>
<td style="text-align:center">XNU 内核</td>
<td style="text-align:center">workqueue</td>
</tr>
</tbody>
</table>
<p>GCD的API全部为在libdispatch库中的C语言函数.<br>Dispatch Queue执行步骤:<br>1.GCD初始化时,使用<code>pthread_workqueue_create_np</code>函数生成<code>pthead_workqueue</code>.<code>pthead_workqueue</code>包含在Libc提供的<code>ptheads API</code>,它使用<code>bsdthead_register</code>和<code>workq_open</code>系统调用.<br>2.<code>dispatch queue</code>通过结构体和链表,被实现为FIFO队列.block不是直接加入FIFO队列.它先加入<code>dispatch continuation</code>这一<code>dispatch_continuation_t</code>类型结构体中,然后再加入FIFO队列.<br>3.当在<code>global dispatch queue</code>中执行block时,<code>libdispatch</code>从<code>global dispatch queue</code>自身的FIFO队列中取出<code>dispatch continuation</code>,调用<code>pthread_workqueue_additem_np</code>函数.将<code>global dispatch queue</code>自身、符合其优先级的workqueue信息以及为执行<code>dispatch continuation</code>的回调函数传递给参数.<br>4.<code>pthread_workqueue_additem_np</code>函数使用<code>workq_kernreturn</code>系统调用,通知<code>workqueue</code>增加应当执行的项目.根据该通知,XNU内核基于系统状态判断是否要生成线程.如果是<code>OverCommit</code>优先级的<code>global dispatch queue</code>,workqueue则始终生成线程.<br>5.<code>workqueue</code>的线程执行<code>pthread_workqueue</code>函数,该函数调用<code>libdispatch</code>的回调函.在该回调函数中中执行加入到<code>dispatch continuation</code>的<code>block</code>.<br>6.<code>block</code>执行结束后,进行通知<code>dispatch group</code>结束、释放<code>dispatch continuation</code>等处理,开始准备执行加入到<code>global dispatch queue</code>中的下一个<code>block</code>.</p>
<h3 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h3><p><a href="http://www.jianshu.com/p/0ceae11385a7" target="_blank" rel="external">iOS读书笔记之Objective-C高级编程(GCD)</a> </p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/读书笔记/" rel="tag"># 读书笔记</a>
          
            <a href="/tags/GCD/" rel="tag"># GCD</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/10/Hexo搭建/" rel="next" title="Hexo搭建">
                <i class="fa fa-chevron-left"></i> Hexo搭建
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/24/iOS读书笔记之Effective Objective-C 2.0/" rel="prev" title="iOS读书笔记之Effective Objective-C 2.0">
                iOS读书笔记之Effective Objective-C 2.0 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yOTA1Ny81NjI2"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>
  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            博主大大
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="cherishJoy" />
          <p class="site-author-name" itemprop="name">cherishJoy</p>
           
              <p class="site-description motion-element" itemprop="description">cherish_joy@163.com</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CherishJoyBy" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/a589d2b37b9c" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-book"></i>
                  
                  简书
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/cherish_joy?viewmode=list" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-envira"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://stackoverflow.com/" title="Stack Overflow" target="_blank">Stack Overflow</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.cnblogs.com/" title="博客园" target="_blank">博客园</a>
                </li>
              
            </ul>
          </div>
        
        
        

        
        
        <div>
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=0 height=0 src="//music.163.com/outchain/player?type=0&id=759477630&auto=1&height=0"></iframe>
        </div>
        
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD的概念"><span class="nav-number">1.</span> <span class="nav-text">GCD的概念.</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GCD-全称是Grand-Central-Dispatch-它是C语言的API"><span class="nav-number">1.1.</span> <span class="nav-text">GCD,全称是Grand Central Dispatch,它是C语言的API.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GCD使用步骤"><span class="nav-number">1.2.</span> <span class="nav-text">GCD使用步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#日常使用"><span class="nav-number">1.3.</span> <span class="nav-text">日常使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程执行原理总结"><span class="nav-number">1.4.</span> <span class="nav-text">多线程执行原理总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CCD的API"><span class="nav-number">2.</span> <span class="nav-text">CCD的API.</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dispatch-Queue"><span class="nav-number">2.1.</span> <span class="nav-text">Dispatch Queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-queue-create"><span class="nav-number">2.2.</span> <span class="nav-text">dispatch_queue_create</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-set-target-queue"><span class="nav-number">2.3.</span> <span class="nav-text">dispatch_set_target_queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-after"><span class="nav-number">2.4.</span> <span class="nav-text">dispatch_after</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-group"><span class="nav-number">2.5.</span> <span class="nav-text">dispatch group</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-barrier-async"><span class="nav-number">2.6.</span> <span class="nav-text">dispatch_barrier_async</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-sync"><span class="nav-number">2.7.</span> <span class="nav-text">dispatch_sync</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-apply"><span class="nav-number">2.8.</span> <span class="nav-text">dispatch_apply</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-suspend"><span class="nav-number">2.9.</span> <span class="nav-text">dispatch_suspend</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-resume"><span class="nav-number">2.10.</span> <span class="nav-text">dispatch_resume</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-semaphore"><span class="nav-number">2.11.</span> <span class="nav-text">dispatch semaphore</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-once"><span class="nav-number">2.12.</span> <span class="nav-text">dispatch_once</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CCD的实现"><span class="nav-number">3.</span> <span class="nav-text">CCD的实现.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简书"><span class="nav-number">4.</span> <span class="nav-text">简书</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherishJoy</span>
</div>


<div class="powered-by">
  Technology Blog
</div>

<div class="theme-info">
  All Rights Reserved
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("hUIOauAOSIOYuI73o8R3vTsa-gzGzoHsz", "DFndnSRESYTVrekVyCxuuzSM");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
</html>
